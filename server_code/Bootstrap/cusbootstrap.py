import anvil.email
import anvil.google.auth, anvil.google.drive, anvil.google.mail
from anvil.google.drive import app_files
import anvil.users
import anvil.tables as tables
import anvil.tables.query as q
from anvil.tables import app_tables
import anvil.server


def cusbootstrap(dx, pointmean, pointname, sdiff, bootnum, total_rows, cusum_control, x, fog, turnpt, z, y, countr, conflimit):
    from sklearn.utils import shuffle
    import numpy as np
    #import plotly.plotly as py
    import plotly.graph_objs as go
    import pandas as pd
    import plotly.tools as tls
    import time
    from datetime import datetime
#     bootnum =100
    # Find and test the confidences level of the change point
    count = 0
    dshuffdiff = [None] * bootnum
   
    loopon = 1
    start_time = time.time()
    # generate random sequence of the points to see if how many exceed the orginal cusum diff
#     print('boot start) '+str(datetime.now()))
    for j in range(0, bootnum - 1):
#         listA =  dx[pointname].to_list()
#         print('perm start) '+str(datetime.now()))
        dx['shuffle'] = np.random.permutation(dx[pointname].values)
#         print('perm end  ) '+str(datetime.now()))
        dx['Diff from mean'] = dx['shuffle'] - pointmean
        dx['ShuffCusum'] = dx['Diff from mean'].cumsum()

        maxcusum = dx['ShuffCusum'].max()
        mincusum = dx['ShuffCusum'].min()

        shuffdiff = maxcusum - mincusum

        # create an list of generated sdiffs for a histogram
#         dshuffdiff[j] = shuffdiff

        #print (shuffdiff)

        # test if the generated sdiif is below the original sdiff
        if shuffdiff > sdiff:
            count = count + 1
#     print('boot  after) '+str(datetime.now()))

    # calculate the the confidence level
    conflevel = 100 * (bootnum - count)/bootnum
#     print ("Time to shuffle cusum in Cusbootstrap",(time.time() - start_time))
#     print('countr=', countr)
    nrows = cusum_control['firstindex'].count()
  
    
    if conflevel < conflimit or turnpt == z:
#         print('-------------------------------------------')
#         print('Confidence Level=', conflevel, 'No rows generated for row', x)
#         print('-------------------------------------------')
#         print('row', x, ' did not generate  a row')
        nrows = cusum_control['firstindex'].count()

    # Test confidence level againt standard 95%
    if conflevel >= conflimit:

#         print('-------------------------------------------')
#         print('Confidence Level=', conflevel, 'for', x, 'creating row =', 1 + (x)*2, ' and row =', 2 + (x)*2)
#         print('-------------------------------------------')

        # Reset the firstindex and last index to run another bootstrap for the first
        # set of points before the change pt

        mincusum = abs(dx['Cusum'].min())
        #print ('Mincusum=',mincusum)
        #print ('Syd')
        firstindex = int(cusum_control['firstindex'].iloc[x])
        #print ('Firstindex1=',firstindex)
        lastindex = turnpt
        #print ('LastIndex1-',lastindex)

        cusum_control = cusum_control.append({'firstindex': firstindex, 'lastindex': lastindex,
                                              'conflevel': conflevel}, ignore_index=True)
#         print('nrows=', nrows)
#         print('x=', x)
#         print('countr=', countr)
#         if x == 0:
# #             print('row', x + 1, 'generated by row', x)
#         if x > 0:
#             print('row', nrows, 'generated2 by row', x)

        fog.append(countr + 1)

#         print('fog', fog)

        firstindex = turnpt
        #print ('Firstindex2=',firstindex)
        lastindex = int(cusum_control['lastindex'].iloc[x])
        #print ('LastIndex2=',lastindex)
#         StageMean =dx[['Value']].iloc[[firstindex,lastindex]].mean()
#         print('StageMean2=', StageMean)

        cusum_control = cusum_control.append({'firstindex': firstindex, 'lastindex': lastindex,
                                              'conflevel': conflevel}, ignore_index=True)
#         limitofloops = 5
#         if len(cusum_control) >= limitofloops:
#             break 
          
             
#         print('nrows=', nrows)
#         print('x=', x)
#         print('countr=', countr)
#         if x == 0:
#             print('row', x + 2, 'generated by row', x)
#         if x > 0:
#             print('row', nrows + 1, 'generated3 by row', x)

        countr = countr + 1

        fog.append(countr + 1)

#         print('fog', fog)

        nrows = cusum_control['firstindex'].count()
#         print(' no. of rows in cusum are', nrows)

        countr = countr + 1

        cusum_control['Expanded'].iloc[x] = 'y'

#         print('countr at end=', countr)
#         print('fog')
#         print(fog)
#         print('Cusum Control')
#         print('----------------------------')
#         print(cusum_control)
#         print ("Time to populate cusum_control in Cusbootstrap",(time.time() - start_time))
#     print ("Time to completion in Cusbootstrap",(time.time() - start_time))
    return conflevel, cusum_control, x, fog, countr
  

